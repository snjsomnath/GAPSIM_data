<!DOCTYPE html>
<html lang="en" data-bs-theme="light">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>location_assignment - Tripsender Documentation</title>
        <link href="../css/bootstrap.min.css" rel="stylesheet">
        <link href="../css/fontawesome.min.css" rel="stylesheet">
        <link href="../css/brands.min.css" rel="stylesheet">
        <link href="../css/solid.min.css" rel="stylesheet">
        <link href="../css/v4-font-face.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link id="hljs-light" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" >
        <link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" disabled>
        <link href="../assets/_mkdocstrings.css" rel="stylesheet">
        <link href="../stylesheets/extra.css" rel="stylesheet">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="..">Tripsender Documentation</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbar-collapse" aria-controls="navbar-collapse" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="nav-item">
                                <a href=".." class="nav-link">Welcome to tripsender</a>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle active" aria-current="page" role="button" data-bs-toggle="dropdown"  aria-expanded="false">API Documentation</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../activity/" class="dropdown-item">activity</a>
</li>
                                    
<li>
    <a href="../building/" class="dropdown-item">building</a>
</li>
                                    
<li>
    <a href="../house/" class="dropdown-item">house</a>
</li>
                                    
<li>
    <a href="../household/" class="dropdown-item">household</a>
</li>
                                    
<li>
    <a href="../io/" class="dropdown-item">io</a>
</li>
                                    
<li>
    <a href="./" class="dropdown-item active" aria-current="page">location_assignment</a>
</li>
                                    
<li>
    <a href="../nhts/" class="dropdown-item">nhts</a>
</li>
                                    
<li>
    <a href="../od/" class="dropdown-item">od</a>
</li>
                                    
<li>
    <a href="../person/" class="dropdown-item">person</a>
</li>
                                    
<li>
    <a href="../population/" class="dropdown-item">population</a>
</li>
                                    
<li>
    <a href="../routing/" class="dropdown-item">routing</a>
</li>
                                    
<li>
    <a href="../sampler/" class="dropdown-item">sampler</a>
</li>
                                    
<li>
    <a href="../synthpop/" class="dropdown-item">synthpop</a>
</li>
                                    
<li>
    <a href="../utils/" class="dropdown-item">utils</a>
</li>
                                    
<li>
    <a href="../validation/" class="dropdown-item">validation</a>
</li>
                                </ul>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ms-md-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-bs-toggle="modal" data-bs-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../io/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../nhts/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-bs-toggle="collapse" data-bs-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-body-tertiary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-bs-level="2"><a href="#tripsender.location_assignment" class="nav-link">location_assignment</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="2"><a href="#tripsender.location_assignment.LocationFinder" class="nav-link">LocationFinder</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="2"><a href="#tripsender.location_assignment.assign_jobs_to_workers" class="nav-link">assign_jobs_to_workers</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="2"><a href="#tripsender.location_assignment.assign_workers_to_buildings" class="nav-link">assign_workers_to_buildings</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="2"><a href="#tripsender.location_assignment.compute_job_density" class="nav-link">compute_job_density</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="2"><a href="#tripsender.location_assignment.compute_preferred_locations" class="nav-link">compute_preferred_locations</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="2"><a href="#tripsender.location_assignment.gravity_model_simulation" class="nav-link">gravity_model_simulation</a>
              <ul class="nav flex-column">
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<div class="doc doc-object doc-module">



<a id="tripsender.location_assignment"></a>
    <div class="doc doc-contents first">



  <div class="doc doc-children">








<div class="doc doc-object doc-class">



<h2 id="tripsender.location_assignment.LocationFinder" class="doc doc-heading">
            <code>LocationFinder</code>


</h2>


    <div class="doc doc-contents ">


      <p>LocationFinder class helps in finding locations based on the given GeoDataFrame and location counts.</p>
<p>This class uses BallTree data structure to efficiently query nearby locations. Different types of locations
(like schools, playgrounds, healthcare, etc.) can be associated with different default counts to prioritize
their significance.</p>

              <details class="quote">
                <summary>Source code in <code>tripsender\location_assignment.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">LocationFinder</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    LocationFinder class helps in finding locations based on the given GeoDataFrame and location counts.</span>

<span class="sd">    This class uses BallTree data structure to efficiently query nearby locations. Different types of locations</span>
<span class="sd">    (like schools, playgrounds, healthcare, etc.) can be associated with different default counts to prioritize</span>
<span class="sd">    their significance.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gdf</span><span class="p">,</span> <span class="n">location_counts</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the LocationFinder with a given GeoDataFrame and optional location counts.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        - gdf (GeoDataFrame): The input GeoDataFrame containing location data.</span>
<span class="sd">        - location_counts (dict, optional): A dictionary specifying the counts for different location types.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gdf</span> <span class="o">=</span> <span class="n">gdf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ball_trees</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Dictionary to store BallTrees for different location types</span>
        <span class="n">count_multiple</span> <span class="o">=</span> <span class="mi">3</span>   <span class="c1"># A multiplier for location counts</span>

        <span class="c1"># Default counts for various location types if none are provided</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_location_counts</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;EDUCATION_förskola&quot;</span> <span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="s2">&quot;EDUCATION_förskoleklass&quot;</span> <span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="s2">&quot;EDUCATION_grundskola&quot;</span> <span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="s2">&quot;EDUCATION_gymnasieskola&quot;</span> <span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="s2">&quot;EDUCATION_fritidshem&quot;</span> <span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="s2">&quot;LEISURE_sports&quot;</span> <span class="p">:</span> <span class="n">count_multiple</span><span class="p">,</span>
            <span class="s2">&quot;LEISURE_playground&quot;</span> <span class="p">:</span> <span class="n">count_multiple</span><span class="p">,</span>
            <span class="s2">&quot;EDUCATION&quot;</span> <span class="p">:</span> <span class="n">count_multiple</span><span class="p">,</span>
            <span class="s2">&quot;SHOPPING_OTHER&quot;</span>    <span class="p">:</span> <span class="n">count_multiple</span><span class="p">,</span>
            <span class="c1"># &quot;SHOPPING_GROCERY&quot; is handled separately</span>
            <span class="s2">&quot;LEISURE&quot;</span>   <span class="p">:</span> <span class="n">count_multiple</span><span class="p">,</span>
            <span class="s2">&quot;HEALTHCARE&quot;</span>    <span class="p">:</span> <span class="n">count_multiple</span>
        <span class="p">}</span>

        <span class="c1"># If custom location counts are provided, update the default counts</span>
        <span class="k">if</span> <span class="n">location_counts</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">default_location_counts</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">location_counts</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">populate_ball_trees</span><span class="p">()</span>  <span class="c1"># Create BallTrees for the location types</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grocery_data</span><span class="p">()</span>    <span class="c1"># Handle grocery data separately (method implementation is not provided)</span>

    <span class="k">def</span> <span class="nf">populate_ball_trees</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Populate the BallTrees for the different location types based on the GeoDataFrame.</span>

<span class="sd">        This method creates a BallTree for each location type listed in default_location_counts, </span>
<span class="sd">        allowing for efficient spatial queries. The BallTree, along with the associated GeoDataFrame</span>
<span class="sd">        subset and its count, is stored in the ball_trees dictionary for each location type.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Iterate over each location type and its associated count</span>
        <span class="k">for</span> <span class="n">loc_type</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_location_counts</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="c1"># Filter the GeoDataFrame based on the current location type</span>
            <span class="n">temp_gdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gdf</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;activity&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">loc_type</span><span class="p">]</span>

            <span class="c1"># Extract the coordinates from the &#39;geometry&#39; column of the filtered GeoDataFrame</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="p">[(</span><span class="n">point</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">point</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">temp_gdf</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">]</span>

            <span class="c1"># If there are coordinates (i.e., there are entries for this location type in the GeoDataFrame),</span>
            <span class="c1"># create a BallTree for them</span>
            <span class="k">if</span> <span class="n">coords</span><span class="p">:</span>
                <span class="c1"># Create a BallTree with the coordinates and use the euclidean metric for spatial queries</span>
                <span class="n">tree</span> <span class="o">=</span> <span class="n">BallTree</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coords</span><span class="p">),</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">)</span>

                <span class="c1"># Store the BallTree, the subset of the GeoDataFrame, and the count in the ball_trees dictionary</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ball_trees</span><span class="p">[</span><span class="n">loc_type</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">temp_gdf</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">set_grocery_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize and set the grocery-related data attributes.</span>

<span class="sd">        This method extracts the data related to the &quot;SHOPPING_GROCERY&quot; activity from the main GeoDataFrame.</span>
<span class="sd">        It sets up the grocery GeoDataFrame, the coordinates of the grocery locations, and their associated areas.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Setting up grocery data...&quot;</span><span class="p">)</span>
        <span class="c1"># Filter the main GeoDataFrame to extract only the rows related to &quot;SHOPPING_GROCERY&quot; activity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grocery_gdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gdf</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;activity&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;SHOPPING_GROCERY&quot;</span><span class="p">]</span>

        <span class="c1"># Extract the x and y coordinates from the &#39;geometry&#39; column of the grocery GeoDataFrame</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grocery_coords</span> <span class="o">=</span> <span class="p">[(</span><span class="n">point</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">point</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grocery_gdf</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">]</span>

        <span class="c1"># Extract the &#39;area&#39; values corresponding to each grocery location</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grocery_areas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grocery_gdf</span><span class="p">[</span><span class="s1">&#39;area&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

    <span class="k">def</span> <span class="nf">find_closest_locations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin_point</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the closest locations to a given origin point for each location type.</span>

<span class="sd">        This method queries the BallTree for each location type to find the closest locations.</span>
<span class="sd">        The number of closest locations for each type is determined by the &#39;k&#39; parameter or </span>
<span class="sd">        the default count associated with the location type.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        - origin_point (Point): The origin point from which distances are measured.</span>
<span class="sd">        - k (int, optional): The number of closest locations to return for each location type. </span>
<span class="sd">                            If not provided, the default count for each type is used.</span>

<span class="sd">        Returns:</span>
<span class="sd">        - results (list): A list containing Location objects for each of the closest locations.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># List to store the resulting Location objects</span>
        <span class="n">origin</span> <span class="o">=</span> <span class="p">(</span><span class="n">origin_point</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">origin_point</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>  <span class="c1"># Convert origin point to tuple format</span>

        <span class="c1"># Iterate over each location type and its associated BallTree, GeoDataFrame subset, and count</span>
        <span class="k">for</span> <span class="n">loc_type</span><span class="p">,</span> <span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">relevant_gdf</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ball_trees</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1">#logger.info(f&quot;Fetching location for location type : {loc_type}&quot;)</span>
            <span class="c1"># Determine the number of closest locations to query. Use provided k or default count.</span>
            <span class="n">current_k</span> <span class="o">=</span> <span class="n">k</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">count</span>  

            <span class="c1"># Query the BallTree to find the closest locations</span>
            <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">([</span><span class="n">origin</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="n">current_k</span><span class="p">)</span>

            <span class="c1"># Extract location data from the relevant GeoDataFrame for each of the closest locations</span>
            <span class="k">for</span> <span class="n">distance</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">distances</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">closest_row</span> <span class="o">=</span> <span class="n">relevant_gdf</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
                <span class="c1">#logger.info(f&quot;Found a location for amenity {loc_type} : {closest_row[&#39;name&#39;]}, {distance}m away&quot;)</span>
                <span class="c1"># Create a Location object and add it to the results list</span>
                <span class="n">location</span> <span class="o">=</span> <span class="n">Location</span><span class="p">(</span><span class="n">loc_type</span><span class="p">,</span> <span class="n">closest_row</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">closest_row</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">],</span> <span class="n">closest_row</span><span class="p">[</span><span class="s1">&#39;amenity&#39;</span><span class="p">])</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">location</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">gravity_score</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">area</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the gravity-based score for a location based on its area and distance from an origin.</span>

<span class="sd">        The gravity model, used here, is a spatial interaction model which is based on the idea </span>
<span class="sd">        that the interaction between two places can be determined by the product of the size of </span>
<span class="sd">        one (or both) and divided by their separation distance raised to a power (distance decay).</span>

<span class="sd">        Parameters:</span>
<span class="sd">        - distance (float): The distance from the origin to the location.</span>
<span class="sd">        - area (float): The size (area) of the location.</span>
<span class="sd">        - alpha (float, optional): The exponent for the area (default is 1.5).</span>
<span class="sd">        - beta (float, optional): The exponent for the distance decay (default is 2).</span>

<span class="sd">        Returns:</span>
<span class="sd">        - float: The gravity score for the location.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">1e-10</span>  <span class="c1"># Small constant to prevent division by zero</span>

        <span class="c1"># Calculate the gravity score using the formula: (area^alpha) / (distance + epsilon)^beta</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">((</span><span class="n">distance</span> <span class="o">+</span> <span class="n">epsilon</span><span class="p">)</span><span class="o">**</span><span class="n">beta</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">find_closest_grocery_locations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin_point</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the closest grocery locations to a given origin point based on a gravity-based scoring system.</span>

<span class="sd">        This method first computes the euclidean distance between the origin point and each grocery location.</span>
<span class="sd">        It then calculates a gravity-based score for each grocery location using the gravity_score method.</span>
<span class="sd">        The top &#39;k&#39; grocery locations with the highest gravity scores are returned.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        - origin_point (Point): The origin point from which distances and scores are calculated.</span>
<span class="sd">        - k (int, optional): The number of top-scoring grocery locations to return (default is 3).</span>

<span class="sd">        Returns:</span>
<span class="sd">        - results (list): A list containing Location objects for each of the top &#39;k&#39; grocery locations.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Convert the origin point to a list format [x, y]</span>
        <span class="n">origin</span> <span class="o">=</span> <span class="p">[</span><span class="n">origin_point</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">origin_point</span><span class="o">.</span><span class="n">y</span><span class="p">]</span>

        <span class="c1"># Calculate the pairwise euclidean distances between the origin and each grocery location</span>
        <span class="n">dist_metric</span> <span class="o">=</span> <span class="n">DistanceMetric</span><span class="o">.</span><span class="n">get_metric</span><span class="p">(</span><span class="s1">&#39;euclidean&#39;</span><span class="p">)</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="n">dist_metric</span><span class="o">.</span><span class="n">pairwise</span><span class="p">([</span><span class="n">origin</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">grocery_coords</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

        <span class="n">areas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grocery_areas</span>  <span class="c1"># Get the areas of the grocery locations</span>
        <span class="c1"># Set all areas to 1 to neutralize their effect</span>
        <span class="n">areas</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>  <span class="c1"># Assuming there is one area value for each distance calculated</span>

        <span class="c1"># Compute gravity scores for each grocery location</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">gravity_score</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">area</span><span class="p">)</span> <span class="k">for</span> <span class="n">dist</span><span class="p">,</span> <span class="n">area</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="n">areas</span><span class="p">)]</span>

        <span class="c1"># Get the indices of the top &#39;k&#39; grocery locations based on the gravity scores</span>
        <span class="n">top_indices</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">scores</span><span class="p">)),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">scores</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)[:</span><span class="n">k</span><span class="p">]</span>

        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># List to store the resulting Location objects</span>

        <span class="c1"># Extract location data from the grocery GeoDataFrame for each of the top &#39;k&#39; locations</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">top_indices</span><span class="p">:</span>
            <span class="n">row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grocery_gdf</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

            <span class="c1"># Create a Location object and add it to the results list</span>
            <span class="n">location</span> <span class="o">=</span> <span class="n">Location</span><span class="p">(</span><span class="s2">&quot;SHOPPING_GROCERY&quot;</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;amenity&#39;</span><span class="p">])</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">location</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h3 id="tripsender.location_assignment.LocationFinder.__init__" class="doc doc-heading">
            <code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">location_counts</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

      <p>Initialize the LocationFinder with a given GeoDataFrame and optional location counts.</p>
<p>Parameters:
- gdf (GeoDataFrame): The input GeoDataFrame containing location data.
- location_counts (dict, optional): A dictionary specifying the counts for different location types.</p>

            <details class="quote">
              <summary>Source code in <code>tripsender\location_assignment.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span>
<span class="normal">73</span>
<span class="normal">74</span>
<span class="normal">75</span>
<span class="normal">76</span>
<span class="normal">77</span>
<span class="normal">78</span>
<span class="normal">79</span>
<span class="normal">80</span>
<span class="normal">81</span>
<span class="normal">82</span>
<span class="normal">83</span>
<span class="normal">84</span>
<span class="normal">85</span>
<span class="normal">86</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gdf</span><span class="p">,</span> <span class="n">location_counts</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initialize the LocationFinder with a given GeoDataFrame and optional location counts.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - gdf (GeoDataFrame): The input GeoDataFrame containing location data.</span>
<span class="sd">    - location_counts (dict, optional): A dictionary specifying the counts for different location types.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">gdf</span> <span class="o">=</span> <span class="n">gdf</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ball_trees</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Dictionary to store BallTrees for different location types</span>
    <span class="n">count_multiple</span> <span class="o">=</span> <span class="mi">3</span>   <span class="c1"># A multiplier for location counts</span>

    <span class="c1"># Default counts for various location types if none are provided</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">default_location_counts</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;EDUCATION_förskola&quot;</span> <span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;EDUCATION_förskoleklass&quot;</span> <span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;EDUCATION_grundskola&quot;</span> <span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;EDUCATION_gymnasieskola&quot;</span> <span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;EDUCATION_fritidshem&quot;</span> <span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;LEISURE_sports&quot;</span> <span class="p">:</span> <span class="n">count_multiple</span><span class="p">,</span>
        <span class="s2">&quot;LEISURE_playground&quot;</span> <span class="p">:</span> <span class="n">count_multiple</span><span class="p">,</span>
        <span class="s2">&quot;EDUCATION&quot;</span> <span class="p">:</span> <span class="n">count_multiple</span><span class="p">,</span>
        <span class="s2">&quot;SHOPPING_OTHER&quot;</span>    <span class="p">:</span> <span class="n">count_multiple</span><span class="p">,</span>
        <span class="c1"># &quot;SHOPPING_GROCERY&quot; is handled separately</span>
        <span class="s2">&quot;LEISURE&quot;</span>   <span class="p">:</span> <span class="n">count_multiple</span><span class="p">,</span>
        <span class="s2">&quot;HEALTHCARE&quot;</span>    <span class="p">:</span> <span class="n">count_multiple</span>
    <span class="p">}</span>

    <span class="c1"># If custom location counts are provided, update the default counts</span>
    <span class="k">if</span> <span class="n">location_counts</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_location_counts</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">location_counts</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">populate_ball_trees</span><span class="p">()</span>  <span class="c1"># Create BallTrees for the location types</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">set_grocery_data</span><span class="p">()</span>    <span class="c1"># Handle grocery data separately (method implementation is not provided)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="tripsender.location_assignment.LocationFinder.find_closest_grocery_locations" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">find_closest_grocery_locations</span><span class="p">(</span><span class="n">origin_point</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

      <p>Find the closest grocery locations to a given origin point based on a gravity-based scoring system.</p>
<p>This method first computes the euclidean distance between the origin point and each grocery location.
It then calculates a gravity-based score for each grocery location using the gravity_score method.
The top 'k' grocery locations with the highest gravity scores are returned.</p>
<p>Parameters:
- origin_point (Point): The origin point from which distances and scores are calculated.
- k (int, optional): The number of top-scoring grocery locations to return (default is 3).</p>
<p>Returns:
- results (list): A list containing Location objects for each of the top 'k' grocery locations.</p>

            <details class="quote">
              <summary>Source code in <code>tripsender\location_assignment.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">find_closest_grocery_locations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin_point</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the closest grocery locations to a given origin point based on a gravity-based scoring system.</span>

<span class="sd">    This method first computes the euclidean distance between the origin point and each grocery location.</span>
<span class="sd">    It then calculates a gravity-based score for each grocery location using the gravity_score method.</span>
<span class="sd">    The top &#39;k&#39; grocery locations with the highest gravity scores are returned.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - origin_point (Point): The origin point from which distances and scores are calculated.</span>
<span class="sd">    - k (int, optional): The number of top-scoring grocery locations to return (default is 3).</span>

<span class="sd">    Returns:</span>
<span class="sd">    - results (list): A list containing Location objects for each of the top &#39;k&#39; grocery locations.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Convert the origin point to a list format [x, y]</span>
    <span class="n">origin</span> <span class="o">=</span> <span class="p">[</span><span class="n">origin_point</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">origin_point</span><span class="o">.</span><span class="n">y</span><span class="p">]</span>

    <span class="c1"># Calculate the pairwise euclidean distances between the origin and each grocery location</span>
    <span class="n">dist_metric</span> <span class="o">=</span> <span class="n">DistanceMetric</span><span class="o">.</span><span class="n">get_metric</span><span class="p">(</span><span class="s1">&#39;euclidean&#39;</span><span class="p">)</span>
    <span class="n">distances</span> <span class="o">=</span> <span class="n">dist_metric</span><span class="o">.</span><span class="n">pairwise</span><span class="p">([</span><span class="n">origin</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">grocery_coords</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

    <span class="n">areas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grocery_areas</span>  <span class="c1"># Get the areas of the grocery locations</span>
    <span class="c1"># Set all areas to 1 to neutralize their effect</span>
    <span class="n">areas</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>  <span class="c1"># Assuming there is one area value for each distance calculated</span>

    <span class="c1"># Compute gravity scores for each grocery location</span>
    <span class="n">scores</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">gravity_score</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">area</span><span class="p">)</span> <span class="k">for</span> <span class="n">dist</span><span class="p">,</span> <span class="n">area</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="n">areas</span><span class="p">)]</span>

    <span class="c1"># Get the indices of the top &#39;k&#39; grocery locations based on the gravity scores</span>
    <span class="n">top_indices</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">scores</span><span class="p">)),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">scores</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)[:</span><span class="n">k</span><span class="p">]</span>

    <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># List to store the resulting Location objects</span>

    <span class="c1"># Extract location data from the grocery GeoDataFrame for each of the top &#39;k&#39; locations</span>
    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">top_indices</span><span class="p">:</span>
        <span class="n">row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grocery_gdf</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

        <span class="c1"># Create a Location object and add it to the results list</span>
        <span class="n">location</span> <span class="o">=</span> <span class="n">Location</span><span class="p">(</span><span class="s2">&quot;SHOPPING_GROCERY&quot;</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;amenity&#39;</span><span class="p">])</span>
        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">location</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">results</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="tripsender.location_assignment.LocationFinder.find_closest_locations" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">find_closest_locations</span><span class="p">(</span><span class="n">origin_point</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

      <p>Find the closest locations to a given origin point for each location type.</p>
<p>This method queries the BallTree for each location type to find the closest locations.
The number of closest locations for each type is determined by the 'k' parameter or 
the default count associated with the location type.</p>
<p>Parameters:
- origin_point (Point): The origin point from which distances are measured.
- k (int, optional): The number of closest locations to return for each location type. 
                    If not provided, the default count for each type is used.</p>
<p>Returns:
- results (list): A list containing Location objects for each of the closest locations.</p>

            <details class="quote">
              <summary>Source code in <code>tripsender\location_assignment.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">find_closest_locations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin_point</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the closest locations to a given origin point for each location type.</span>

<span class="sd">    This method queries the BallTree for each location type to find the closest locations.</span>
<span class="sd">    The number of closest locations for each type is determined by the &#39;k&#39; parameter or </span>
<span class="sd">    the default count associated with the location type.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - origin_point (Point): The origin point from which distances are measured.</span>
<span class="sd">    - k (int, optional): The number of closest locations to return for each location type. </span>
<span class="sd">                        If not provided, the default count for each type is used.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - results (list): A list containing Location objects for each of the closest locations.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># List to store the resulting Location objects</span>
    <span class="n">origin</span> <span class="o">=</span> <span class="p">(</span><span class="n">origin_point</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">origin_point</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>  <span class="c1"># Convert origin point to tuple format</span>

    <span class="c1"># Iterate over each location type and its associated BallTree, GeoDataFrame subset, and count</span>
    <span class="k">for</span> <span class="n">loc_type</span><span class="p">,</span> <span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">relevant_gdf</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ball_trees</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1">#logger.info(f&quot;Fetching location for location type : {loc_type}&quot;)</span>
        <span class="c1"># Determine the number of closest locations to query. Use provided k or default count.</span>
        <span class="n">current_k</span> <span class="o">=</span> <span class="n">k</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">count</span>  

        <span class="c1"># Query the BallTree to find the closest locations</span>
        <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">([</span><span class="n">origin</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="n">current_k</span><span class="p">)</span>

        <span class="c1"># Extract location data from the relevant GeoDataFrame for each of the closest locations</span>
        <span class="k">for</span> <span class="n">distance</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">distances</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">closest_row</span> <span class="o">=</span> <span class="n">relevant_gdf</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="c1">#logger.info(f&quot;Found a location for amenity {loc_type} : {closest_row[&#39;name&#39;]}, {distance}m away&quot;)</span>
            <span class="c1"># Create a Location object and add it to the results list</span>
            <span class="n">location</span> <span class="o">=</span> <span class="n">Location</span><span class="p">(</span><span class="n">loc_type</span><span class="p">,</span> <span class="n">closest_row</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">closest_row</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">],</span> <span class="n">closest_row</span><span class="p">[</span><span class="s1">&#39;amenity&#39;</span><span class="p">])</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">location</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">results</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="tripsender.location_assignment.LocationFinder.gravity_score" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">gravity_score</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">area</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

      <p>Calculate the gravity-based score for a location based on its area and distance from an origin.</p>
<p>The gravity model, used here, is a spatial interaction model which is based on the idea 
that the interaction between two places can be determined by the product of the size of 
one (or both) and divided by their separation distance raised to a power (distance decay).</p>
<p>Parameters:
- distance (float): The distance from the origin to the location.
- area (float): The size (area) of the location.
- alpha (float, optional): The exponent for the area (default is 1.5).
- beta (float, optional): The exponent for the distance decay (default is 2).</p>
<p>Returns:
- float: The gravity score for the location.</p>

            <details class="quote">
              <summary>Source code in <code>tripsender\location_assignment.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">gravity_score</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">area</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the gravity-based score for a location based on its area and distance from an origin.</span>

<span class="sd">    The gravity model, used here, is a spatial interaction model which is based on the idea </span>
<span class="sd">    that the interaction between two places can be determined by the product of the size of </span>
<span class="sd">    one (or both) and divided by their separation distance raised to a power (distance decay).</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - distance (float): The distance from the origin to the location.</span>
<span class="sd">    - area (float): The size (area) of the location.</span>
<span class="sd">    - alpha (float, optional): The exponent for the area (default is 1.5).</span>
<span class="sd">    - beta (float, optional): The exponent for the distance decay (default is 2).</span>

<span class="sd">    Returns:</span>
<span class="sd">    - float: The gravity score for the location.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">1e-10</span>  <span class="c1"># Small constant to prevent division by zero</span>

    <span class="c1"># Calculate the gravity score using the formula: (area^alpha) / (distance + epsilon)^beta</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">((</span><span class="n">distance</span> <span class="o">+</span> <span class="n">epsilon</span><span class="p">)</span><span class="o">**</span><span class="n">beta</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="tripsender.location_assignment.LocationFinder.populate_ball_trees" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">populate_ball_trees</span><span class="p">()</span></code>

</h3>


    <div class="doc doc-contents ">

      <p>Populate the BallTrees for the different location types based on the GeoDataFrame.</p>
<p>This method creates a BallTree for each location type listed in default_location_counts, 
allowing for efficient spatial queries. The BallTree, along with the associated GeoDataFrame
subset and its count, is stored in the ball_trees dictionary for each location type.</p>

            <details class="quote">
              <summary>Source code in <code>tripsender\location_assignment.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">populate_ball_trees</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Populate the BallTrees for the different location types based on the GeoDataFrame.</span>

<span class="sd">    This method creates a BallTree for each location type listed in default_location_counts, </span>
<span class="sd">    allowing for efficient spatial queries. The BallTree, along with the associated GeoDataFrame</span>
<span class="sd">    subset and its count, is stored in the ball_trees dictionary for each location type.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Iterate over each location type and its associated count</span>
    <span class="k">for</span> <span class="n">loc_type</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_location_counts</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

        <span class="c1"># Filter the GeoDataFrame based on the current location type</span>
        <span class="n">temp_gdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gdf</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;activity&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">loc_type</span><span class="p">]</span>

        <span class="c1"># Extract the coordinates from the &#39;geometry&#39; column of the filtered GeoDataFrame</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="p">[(</span><span class="n">point</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">point</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">temp_gdf</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">]</span>

        <span class="c1"># If there are coordinates (i.e., there are entries for this location type in the GeoDataFrame),</span>
        <span class="c1"># create a BallTree for them</span>
        <span class="k">if</span> <span class="n">coords</span><span class="p">:</span>
            <span class="c1"># Create a BallTree with the coordinates and use the euclidean metric for spatial queries</span>
            <span class="n">tree</span> <span class="o">=</span> <span class="n">BallTree</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coords</span><span class="p">),</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">)</span>

            <span class="c1"># Store the BallTree, the subset of the GeoDataFrame, and the count in the ball_trees dictionary</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ball_trees</span><span class="p">[</span><span class="n">loc_type</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">temp_gdf</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="tripsender.location_assignment.LocationFinder.set_grocery_data" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">set_grocery_data</span><span class="p">()</span></code>

</h3>


    <div class="doc doc-contents ">

      <p>Initialize and set the grocery-related data attributes.</p>
<p>This method extracts the data related to the "SHOPPING_GROCERY" activity from the main GeoDataFrame.
It sets up the grocery GeoDataFrame, the coordinates of the grocery locations, and their associated areas.</p>

            <details class="quote">
              <summary>Source code in <code>tripsender\location_assignment.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">set_grocery_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initialize and set the grocery-related data attributes.</span>

<span class="sd">    This method extracts the data related to the &quot;SHOPPING_GROCERY&quot; activity from the main GeoDataFrame.</span>
<span class="sd">    It sets up the grocery GeoDataFrame, the coordinates of the grocery locations, and their associated areas.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Setting up grocery data...&quot;</span><span class="p">)</span>
    <span class="c1"># Filter the main GeoDataFrame to extract only the rows related to &quot;SHOPPING_GROCERY&quot; activity</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">grocery_gdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gdf</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;activity&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;SHOPPING_GROCERY&quot;</span><span class="p">]</span>

    <span class="c1"># Extract the x and y coordinates from the &#39;geometry&#39; column of the grocery GeoDataFrame</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">grocery_coords</span> <span class="o">=</span> <span class="p">[(</span><span class="n">point</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">point</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grocery_gdf</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">]</span>

    <span class="c1"># Extract the &#39;area&#39; values corresponding to each grocery location</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">grocery_areas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grocery_gdf</span><span class="p">[</span><span class="s1">&#39;area&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>


<div class="doc doc-object doc-function">


<h2 id="tripsender.location_assignment.assign_jobs_to_workers" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">assign_jobs_to_workers</span><span class="p">(</span><span class="n">gdf_homes</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

      <p>Assign job locations to workers residing in the buildings of gdf_homes.</p>
<p>For each building in the GeoDataFrame, the function takes the potential job locations and 
assigns these to every worker residing in that building.</p>
      <ul>
<li>gdf_homes (GeoDataFrame): A GeoDataFrame containing home data. It should have 'building' 
  and 'potential_jobs' columns, where 'building' objects have a 'worker_list' attribute, and each 
  worker in this list has a 'work_location' attribute.</li>
</ul>
<p>Returns:
- None: The function modifies the 'work_location' attribute of each worker in-place.</p>

            <details class="quote">
              <summary>Source code in <code>tripsender\location_assignment.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">assign_jobs_to_workers</span><span class="p">(</span><span class="n">gdf_homes</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assign job locations to workers residing in the buildings of gdf_homes.</span>

<span class="sd">    For each building in the GeoDataFrame, the function takes the potential job locations and </span>
<span class="sd">    assigns these to every worker residing in that building.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - gdf_homes (GeoDataFrame): A GeoDataFrame containing home data. It should have &#39;building&#39; </span>
<span class="sd">      and &#39;potential_jobs&#39; columns, where &#39;building&#39; objects have a &#39;worker_list&#39; attribute, and each </span>
<span class="sd">      worker in this list has a &#39;work_location&#39; attribute.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - None: The function modifies the &#39;work_location&#39; attribute of each worker in-place.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Go through each row of the GeoDataFrame</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">gdf_homes</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">building</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;building&#39;</span><span class="p">]</span>           <span class="c1"># Retrieve the building object</span>
        <span class="n">job_locations</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;potential_jobs&#39;</span><span class="p">]</span> <span class="c1"># Retrieve the potential job locations for this building</span>

        <span class="c1"># Iterate over each worker in the building</span>
        <span class="k">for</span> <span class="n">worker</span><span class="p">,</span><span class="n">job_point</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">building</span><span class="o">.</span><span class="n">worker_list</span><span class="p">,</span> <span class="n">job_locations</span><span class="p">):</span>
            <span class="c1"># Assign the job location to the worker&#39;s work_location attribute</span>
            <span class="n">job_location</span> <span class="o">=</span> <span class="n">Location</span><span class="p">(</span><span class="s2">&quot;WORK&quot;</span><span class="p">,</span> <span class="s2">&quot;Work&quot;</span><span class="p">,</span> <span class="n">job_point</span><span class="p">,</span> <span class="s2">&quot;WORK&quot;</span><span class="p">)</span>
            <span class="n">worker</span><span class="o">.</span><span class="n">work_location</span> <span class="o">=</span> <span class="n">job_location</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="tripsender.location_assignment.assign_workers_to_buildings" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">assign_workers_to_buildings</span><span class="p">()</span></code>

</h2>


    <div class="doc doc-contents ">

      <p>Assigns workers to buildings based on their primary status.</p>

            <details class="quote">
              <summary>Source code in <code>tripsender\location_assignment.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">assign_workers_to_buildings</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Assigns workers to buildings based on their primary status.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Add workers to buildings</span>
    <span class="k">for</span> <span class="n">building</span> <span class="ow">in</span> <span class="n">Building</span><span class="o">.</span><span class="n">instances</span><span class="p">:</span>
        <span class="n">houses</span> <span class="o">=</span> <span class="n">building</span><span class="o">.</span><span class="n">houses</span>
        <span class="k">for</span> <span class="n">house</span> <span class="ow">in</span> <span class="n">houses</span><span class="p">:</span>
            <span class="n">household</span> <span class="o">=</span> <span class="n">house</span><span class="o">.</span><span class="n">household</span>
            <span class="k">for</span> <span class="n">member</span> <span class="ow">in</span> <span class="n">household</span><span class="o">.</span><span class="n">members</span><span class="p">:</span>
                <span class="c1"># Workers is a list of workers with primary_status = &quot;WORK&quot;</span>
                <span class="k">if</span> <span class="n">member</span><span class="o">.</span><span class="n">primary_status</span> <span class="o">==</span> <span class="s2">&quot;WORK&quot;</span><span class="p">:</span>
                    <span class="n">building</span><span class="o">.</span><span class="n">workers</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">building</span><span class="o">.</span><span class="n">worker_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">member</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="tripsender.location_assignment.compute_job_density" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">compute_job_density</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

      <p>Computes job densities for each point in the GeoDataFrame using the given radius.</p>
<p>The function loads a shapefile, calculates the centroid for each geometry and then computes
the job density around each centroid using a given radius. The BallTree data structure is 
utilized for efficient spatial queries.</p>
<p>Parameters:
- file_path (str): Path to the shapefile.
- radius (float): Radius in meters for which job density is calculated. Default is 1000 meters.</p>
<p>Returns:
- gdf_jobs (GeoDataFrame): Updated GeoDataFrame with job densities.</p>

            <details class="quote">
              <summary>Source code in <code>tripsender\location_assignment.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">compute_job_density</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes job densities for each point in the GeoDataFrame using the given radius.</span>

<span class="sd">    The function loads a shapefile, calculates the centroid for each geometry and then computes</span>
<span class="sd">    the job density around each centroid using a given radius. The BallTree data structure is </span>
<span class="sd">    utilized for efficient spatial queries.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - file_path (str): Path to the shapefile.</span>
<span class="sd">    - radius (float): Radius in meters for which job density is calculated. Default is 1000 meters.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - gdf_jobs (GeoDataFrame): Updated GeoDataFrame with job densities.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Computing job densities...&quot;</span><span class="p">)</span>
    <span class="c1"># Load data from the shapefile</span>
    <span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>

    <span class="c1"># Compute centroids for each geometry in the GeoDataFrame</span>
    <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;centroid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">centroid</span>

    <span class="c1"># Create a new GeoDataFrame with only the &#39;jobs&#39; column and the computed centroids</span>
    <span class="c1"># Set the &#39;centroid&#39; column as the geometry for this new GeoDataFrame</span>
    <span class="n">gdf_jobs</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[[</span><span class="s1">&#39;jobs&#39;</span><span class="p">,</span> <span class="s1">&#39;centroid&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">gdf_jobs</span> <span class="o">=</span> <span class="n">gdf_jobs</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="s1">&#39;centroid&#39;</span><span class="p">)</span>

    <span class="c1"># Convert the GeoDataFrame&#39;s point geometries to a matrix format suitable for BallTree</span>
    <span class="n">coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">gdf_jobs</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">gdf_jobs</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">y</span><span class="p">)))</span>

    <span class="c1"># Construct a BallTree for efficient spatial queries</span>
    <span class="n">ball_tree</span> <span class="o">=</span> <span class="n">BallTree</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>

    <span class="c1"># Define an inner function to perform spatial queries and calculate job density</span>
    <span class="k">def</span> <span class="nf">job_density</span><span class="p">(</span><span class="n">point</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute job density for a given point by querying nearby jobs within the specified radius.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        - point (tuple): A tuple representing the x and y coordinates of the point.</span>

<span class="sd">        Returns:</span>
<span class="sd">        - float: Job density for the given point.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the indices of points within the given radius using the BallTree</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">ball_tree</span><span class="o">.</span><span class="n">query_radius</span><span class="p">([</span><span class="n">point</span><span class="p">],</span> <span class="n">r</span><span class="o">=</span><span class="n">radius</span><span class="p">,</span> <span class="n">return_distance</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Sum up the jobs for the queried points to compute the density</span>
        <span class="k">return</span> <span class="n">gdf_jobs</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">indices</span><span class="p">][</span><span class="s1">&#39;jobs&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="c1"># Compute job densities for each point in the GeoDataFrame</span>
    <span class="n">gdf_jobs</span><span class="p">[</span><span class="s1">&#39;job_density&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">job_density</span><span class="p">(</span><span class="n">point</span><span class="p">)</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">coordinates</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">gdf_jobs</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="tripsender.location_assignment.compute_preferred_locations" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">compute_preferred_locations</span><span class="p">(</span><span class="n">add_proposed_locations</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

      <h3 id="tripsender.location_assignment.compute_preferred_locations--todo-this-can-be-made-faster-by-grouping-buildings-into-chunks-of-200x200m-and-assigning-them-together">TODO This can be made faster by grouping buildings into chunks of 200x200m and assigning them together.</h3>
<p>Computes and assigns preferred locations for each building instance based on their coordinates.</p>
<p>For each building in the list of instances, this function:
1. Determines the building's coordinate.
2. Finds the closest general locations to that coordinate.
3. Finds the closest grocery locations to that coordinate.
4. Merges the two lists of locations.
5. Initializes a PreferredLocations object using the combined locations.
6. Assigns the PreferredLocations object to the building's preferred_locations attribute.</p>

            <details class="quote">
              <summary>Source code in <code>tripsender\location_assignment.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">compute_preferred_locations</span><span class="p">(</span><span class="n">add_proposed_locations</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    #TODO This can be made faster by grouping buildings into chunks of 200x200m and assigning them together.</span>
<span class="sd">    Computes and assigns preferred locations for each building instance based on their coordinates.</span>

<span class="sd">    For each building in the list of instances, this function:</span>
<span class="sd">    1. Determines the building&#39;s coordinate.</span>
<span class="sd">    2. Finds the closest general locations to that coordinate.</span>
<span class="sd">    3. Finds the closest grocery locations to that coordinate.</span>
<span class="sd">    4. Merges the two lists of locations.</span>
<span class="sd">    5. Initializes a PreferredLocations object using the combined locations.</span>
<span class="sd">    6. Assigns the PreferredLocations object to the building&#39;s preferred_locations attribute.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Computing preferred locations...&quot;</span><span class="p">)</span>
    <span class="n">gdf_amenities</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">ALL_AMENITIES_PATH</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">add_proposed_locations</span><span class="p">:</span>
        <span class="c1"># Check if the proposed amenities file exists</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">PROPOSED_AMENITIES_PATH</span><span class="p">):</span>

            <span class="c1"># Load the proposed amenities GeoJSON file</span>
            <span class="n">gdf_proposed_amenities</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">PROPOSED_AMENITIES_PATH</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gdf_proposed_amenities</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Proposed amenities file found. Combining amenities for location assignment&quot;</span><span class="p">)</span>
                <span class="c1"># Set the CRS for the proposed amenities GeoDataFrame</span>
                <span class="n">gdf_proposed_amenities</span><span class="o">.</span><span class="n">set_crs</span><span class="p">(</span><span class="n">epsg</span><span class="o">=</span><span class="mi">3006</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">allow_override</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="c1"># Concatenate the existing and proposed amenities into one GeoDataFrame</span>
                <span class="n">gdf_amenities</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">gdf_amenities</span><span class="p">,</span> <span class="n">gdf_proposed_amenities</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">gdf_proposed_amenities</span><span class="o">.</span><span class="n">activity</span><span class="o">.</span><span class="n">value_counts</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Proposed amenities are empty or no proposed amenities file found. Proceeding with location assignment&quot;</span><span class="p">)</span>

    <span class="c1"># Initialize the LocationFinder object outside the loop </span>
    <span class="c1"># (since it probably doesn&#39;t need to be re-initialized for each building).</span>
    <span class="n">location_finder</span> <span class="o">=</span> <span class="n">LocationFinder</span><span class="p">(</span><span class="n">gdf_amenities</span><span class="p">)</span>

    <span class="c1"># Loop through all the building instances</span>
    <span class="k">for</span> <span class="n">building</span> <span class="ow">in</span> <span class="n">Building</span><span class="o">.</span><span class="n">instances</span><span class="p">:</span>
        <span class="c1"># Extract the coordinate (centroid) of the building</span>
        <span class="n">origin</span> <span class="o">=</span> <span class="n">building</span><span class="o">.</span><span class="n">coord</span>

        <span class="c1"># Find the closest general locations to the building&#39;s coordinate</span>
        <span class="n">locations</span> <span class="o">=</span> <span class="n">location_finder</span><span class="o">.</span><span class="n">find_closest_locations</span><span class="p">(</span><span class="n">origin</span><span class="p">)</span>

        <span class="c1"># Find the closest grocery locations to the building&#39;s coordinate</span>
        <span class="n">grocery_locations</span> <span class="o">=</span> <span class="n">location_finder</span><span class="o">.</span><span class="n">find_closest_grocery_locations</span><span class="p">(</span><span class="n">origin</span><span class="p">)</span>

        <span class="c1"># Initialize a PreferredLocations object using the combined lists of locations</span>
        <span class="n">preferred_locations</span> <span class="o">=</span> <span class="n">PreferredLocations</span><span class="p">(</span><span class="n">locations</span> <span class="o">+</span> <span class="n">grocery_locations</span><span class="p">)</span>
        <span class="n">preferred_locations</span><span class="o">.</span><span class="n">origin</span> <span class="o">=</span> <span class="n">origin</span>

        <span class="c1"># Assign the generated PreferredLocations object to the building&#39;s attribute</span>
        <span class="n">building</span><span class="o">.</span><span class="n">preferred_locations</span> <span class="o">=</span> <span class="n">preferred_locations</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Preferred locations computed for </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">Building</span><span class="o">.</span><span class="n">instances</span><span class="p">)</span><span class="si">}</span><span class="s2"> buildings.&quot;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="tripsender.location_assignment.gravity_model_simulation" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">gravity_model_simulation</span><span class="p">(</span><span class="n">gdf_homes</span><span class="p">,</span> <span class="n">gdf_jobs</span><span class="p">,</span> <span class="n">density_weight</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">distance_decay</span><span class="o">=</span><span class="mf">2.5</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

      <p>Simulate job attraction based on the gravity model.</p>
<p>The gravity model is a spatial interaction model that suggests that interaction between two places
(for example, the number of people that commute from one place to another for work) is proportional to 
the product of the population of the two places and inversely proportional to the square of the distance 
between them.</p>
<p>Parameters:
- gdf_homes (GeoDataFrame): A GeoDataFrame containing home data. It must have 'footprint' and 'workers' columns.
- gdf_jobs (GeoDataFrame): A GeoDataFrame containing job location data. It must have a 'job_density' column.
- density_weight (float): The weight to apply to job density in the attraction calculation. Default is 1.
- distance_decay (float): The power to which distance is raised in the attraction calculation. Default is 2.
- plot (bool): Whether or not to plot the results. Default is True.</p>
<p>Returns:
- gdf_worker_jobs (GeoDataFrame): A GeoDataFrame representing the relationship between homes and potential job locations.</p>
<p>To skew the attraction towards job density - increase the density_weight.
To skew the attraction towards distance - increase the distance_decay.</p>

            <details class="quote">
              <summary>Source code in <code>tripsender\location_assignment.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">gravity_model_simulation</span><span class="p">(</span><span class="n">gdf_homes</span><span class="p">,</span> <span class="n">gdf_jobs</span><span class="p">,</span> <span class="n">density_weight</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>  <span class="n">distance_decay</span><span class="o">=</span><span class="mf">2.5</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simulate job attraction based on the gravity model.</span>

<span class="sd">    The gravity model is a spatial interaction model that suggests that interaction between two places</span>
<span class="sd">    (for example, the number of people that commute from one place to another for work) is proportional to </span>
<span class="sd">    the product of the population of the two places and inversely proportional to the square of the distance </span>
<span class="sd">    between them.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - gdf_homes (GeoDataFrame): A GeoDataFrame containing home data. It must have &#39;footprint&#39; and &#39;workers&#39; columns.</span>
<span class="sd">    - gdf_jobs (GeoDataFrame): A GeoDataFrame containing job location data. It must have a &#39;job_density&#39; column.</span>
<span class="sd">    - density_weight (float): The weight to apply to job density in the attraction calculation. Default is 1.</span>
<span class="sd">    - distance_decay (float): The power to which distance is raised in the attraction calculation. Default is 2.</span>
<span class="sd">    - plot (bool): Whether or not to plot the results. Default is True.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - gdf_worker_jobs (GeoDataFrame): A GeoDataFrame representing the relationship between homes and potential job locations.</span>

<span class="sd">    To skew the attraction towards job density - increase the density_weight.</span>
<span class="sd">    To skew the attraction towards distance - increase the distance_decay.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># 1. Calculate Distance Matrix</span>
    <span class="c1"># Extracting the coordinates of home and job centroids</span>
    <span class="n">homes_coords</span> <span class="o">=</span> <span class="n">gdf_homes</span><span class="o">.</span><span class="n">footprint</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">geom</span><span class="p">:</span> <span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">geom</span><span class="o">.</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">jobs_coords</span> <span class="o">=</span> <span class="n">gdf_jobs</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">geom</span><span class="p">:</span> <span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">geom</span><span class="o">.</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="c1"># Computing the distance matrix</span>
    <span class="n">distance_matrix</span> <span class="o">=</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="n">homes_coords</span><span class="p">,</span> <span class="n">jobs_coords</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">)</span>

    <span class="c1"># 2. Gravity Model Calculation</span>
    <span class="c1"># Compute attraction based on job density and distance decay</span>
    <span class="n">attraction_matrix</span> <span class="o">=</span> <span class="p">(</span><span class="n">gdf_jobs</span><span class="p">[</span><span class="s1">&#39;job_density&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">**</span> <span class="n">density_weight</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">distance_matrix</span> <span class="o">**</span> <span class="n">distance_decay</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_job_locations</span><span class="p">(</span><span class="n">row_index</span><span class="p">,</span> <span class="n">n_jobs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For each home, get the most attractive job locations based on the gravity model.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        - row_index (int): The index of the home row.</span>
<span class="sd">        - n_jobs (int): The number of jobs associated with the home.</span>

<span class="sd">        Returns:</span>
<span class="sd">        - list: A list of the most attractive job locations&#39; centroids.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Getting the indices of job locations with the highest attraction</span>
        <span class="n">top_jobs_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">attraction_matrix</span><span class="p">[</span><span class="n">row_index</span><span class="p">])[</span><span class="o">-</span><span class="n">n_jobs</span><span class="p">:]</span>
        <span class="n">unique_jobs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="c1"># Picking the top n_jobs from the list</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">top_jobs_indices</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_jobs</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n_jobs</span><span class="p">:</span>
                <span class="n">unique_jobs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">gdf_jobs</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">unique_jobs</span><span class="p">)][</span><span class="s1">&#39;centroid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="c1"># Assign potential job locations for each home based on number of workers and attraction</span>
    <span class="n">gdf_homes</span><span class="p">[</span><span class="s1">&#39;potential_jobs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_job_locations</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">workers</span><span class="p">))</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">workers</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gdf_homes</span><span class="p">[</span><span class="s1">&#39;workers&#39;</span><span class="p">])]</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Assigning jobs to workers...&quot;</span><span class="p">)</span>

    <span class="c1"># Assign job locations to workers</span>
    <span class="n">assign_jobs_to_workers</span><span class="p">(</span><span class="n">gdf_homes</span><span class="p">)</span>

    <span class="c1"># Data aggregation</span>
    <span class="c1"># Constructing the resultant data</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">home_row</span> <span class="ow">in</span> <span class="n">gdf_homes</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">home_footprint</span> <span class="o">=</span> <span class="n">home_row</span><span class="o">.</span><span class="n">footprint</span>
        <span class="n">home_centroid</span> <span class="o">=</span> <span class="n">home_row</span><span class="o">.</span><span class="n">footprint</span><span class="o">.</span><span class="n">centroid</span>
        <span class="k">for</span> <span class="n">job_point</span> <span class="ow">in</span> <span class="n">home_row</span><span class="p">[</span><span class="s1">&#39;potential_jobs&#39;</span><span class="p">]:</span>
            <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                <span class="s1">&#39;home_footprint&#39;</span><span class="p">:</span> <span class="n">home_footprint</span><span class="p">,</span>
                <span class="s1">&#39;home_centroid&#39;</span><span class="p">:</span> <span class="n">home_centroid</span><span class="p">,</span>
                <span class="s1">&#39;worker&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                <span class="s1">&#39;job_location&#39;</span><span class="p">:</span> <span class="n">job_point</span>
            <span class="p">})</span>

    <span class="c1"># Convert the list of dictionaries to a DataFrame and then to a GeoDataFrame</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">gdf_worker_jobs</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="s1">&#39;job_location&#39;</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">gdf_homes</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="c1"># Visualize the result</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
        <span class="n">gpd</span><span class="o">.</span><span class="n">GeoSeries</span><span class="p">(</span><span class="n">gdf_worker_jobs</span><span class="p">[</span><span class="s1">&#39;home_footprint&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;grey&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">gpd</span><span class="o">.</span><span class="n">GeoSeries</span><span class="p">(</span><span class="n">gdf_worker_jobs</span><span class="p">[</span><span class="s1">&#39;home_centroid&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">gpd</span><span class="o">.</span><span class="n">GeoSeries</span><span class="p">(</span><span class="n">gdf_worker_jobs</span><span class="p">[</span><span class="s1">&#39;job_location&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">gdf_worker_jobs</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../js/bootstrap.bundle.min.js"></script>
        <script>
            var base_url = "..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../js/base.js"></script>
        <script src="../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
